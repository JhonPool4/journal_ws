#!/usr/bin/env python3

# ============================================================
#	Curso   :   Concytec - UTEC
# 	Alumno  :   Jhon Charaja
# 	Info	:	articular PD controller with optimal adaptation 
#				in terms of position and jerk error.
"""
	Notes:
	-----
	- Position error is more stable than jerk error
	- Jerk error show several peaks
	- A filter should be used to smooth the jerk error signal.
	- The optimization equations cause the control gains to stabilize at 0,
	  for control gains with initial value greather than 1. (Experimental observation)
	- For this reason, the simulation use 0.5 as initial control gain.
	
	Updates:
	-------
	- Reference model and trajectory
	- New formulation of dP2_q (dP2 / dq)
"""
# ============================================================

# ============================
# 			Libraries
# ============================ 
import rospy 							# ROS with Python
import os 								# Manipulate path names
import pandas as pd 					# Save data
from sensor_msgs.msg import JointState 	# To send angular position to robot
from markers import *					# To show a market ball 
from functions import *					# Forward Kinematics, Inverse Kinematics and Forward Dynamic
from roslib import packages				# Library with ROS packages
import rbdl								# Library to compute dynamic matrix H and B of robot
pi = np.pi 								# Define "pi"
from datetime import datetime

# ===============================
# 		Configuration of node
# ===============================
# Create a nodo: SMC_controller
rospy.init_node("PDi_controller_ur5")
cwd = os.path.dirname(os.path.realpath(__file__))


# Public in topic /joint_states	to send joint data		
pub = rospy.Publisher('joint_states', JointState, queue_size=1000)

# ===============================
# 		Line and Ball Marker
# ===============================
# Show a ball marker for current and desired position of robot' end-effector
bmarker_des 	= BallMarker(color['GREEN'])
bmarker_act  	= BallMarker(color['YELLOW'])

# =============================================================
# 					Robot Dynamics
# =============================================================
modelo = rbdl.loadModel(os.path.join(cwd,'../../ur5_description/urdf/ur5_joint_limited_robot.urdf'))
ndof   = modelo.q_size     # Degrees of Freedom

# Generar objeto/espacio del vector b y M
b = np.zeros(ndof)
M = np.zeros((ndof,ndof))

# Joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']

# Object(messague) type JointState
jstate = JointState()

# Loop rate (in Hz)
rate 	= rospy.Rate(100)		# 100 [Hz]
dt 		= 1e-2					# 10  [ms]

# =============================================================
# 				Set home joint configuration of UR5
# =============================================================
#  Home joint configuration of ur5 robot (radians)
q 		    = np.array([0.22555947, -2.16092376, -2.13975583, -0.41997402,  1.53827725, -1.35006513]) # Center [0.5 +0.0 0.0]
dq 			= np.zeros(ndof)
ddq 		= np.zeros(ndof)

# Reference angular position, velocity and acceleration
x_ref   = np.zeros(7)
dx_ref  = np.zeros(7)
ddx_ref = np.zeros(7)
# First reference cartesian point
x_ref   = get_current_pose(q)

# Desired angular position, velocity and acceleration
q_des 	 = np.zeros(6)  
dq_des   = np.zeros(6)
ddq_des  = np.zeros(6)
dddq_des = np.zeros(6)
# First desired joint configuration
q_des, dq_des, ddq_des, dddq_des = ikine_pose_ur5_configuration(x_ref, dx_ref, q, dq, ddq)

# Desired cartesian position, velocity, acceleration and jerk
x_des    = np.zeros(7)
x_des[3:7] = np.array([0.01676998,  0.99985616,  0.00251062,  0.00]) # fixed orientation
dx_des 	 = np.zeros(7)
ddx_des  = np.zeros(7)
dddx_des = np.zeros(7)

# Measured angular position, velocity and acceleration
x_act 	 = np.zeros(7)
dx_act 	 = np.zeros(7)
ddx_act  = np.zeros(7)
dddx_act = np.zeros(7)

# Past velocity and acceleration
dx_act_p  = np.zeros(7)
ddx_act_p = np.zeros(7)

# Error angular position, velocity and acceleration
x_e    = np.zeros(7)
dx_e   = np.zeros(7)
ddx_e  = np.zeros(7)
dddx_e = np.zeros(7)

# Create a object Robot with dynamics of UR5 robot (code in Functions)
UR5_robot = Robot(q, dq, ndof, dt)

# ================================
# 			PD controller
# ================================
alpha = 50*dt # 10 50 80
gamma = 0.8
beta  = 0.2
KP    = 0.5*np.array([1, 1, 1, 1, 1, 1])
KD    = 2*np.sqrt(KP)
dJ_KP = np.zeros(6)
dJ_KD = np.zeros(6)
dKP = np.zeros(6)
dKD = np.zeros(6)

u  = np.zeros(6)
up = np.zeros(6)

# ================================
# 		Dynamic simulation
# ================================
t = 0.0
t_reach = 20 # secs

origin 	= './Data/PDi'
suffix 	= 'circular_traj'
folder = os.path.join(cwd, origin, suffix)

column_names = [
	'x', 'y', 'z', 'w', 'ex', 'ey', 'ez',
	'dx', 'dy', 'dz', 'dw', 'dex', 'dey', 'dez',	
	'ddx', 'ddy', 'ddz', 'ddw', 'ddex', 'ddey', 'ddez',
	'dddx', 'dddy', 'dddz', 'dddw', 'dddex', 'dddey', 'dddez',

	'x_des', 'y_des', 'z_des', 'w_des', 'ex_des', 'ey_des', 'ez_des',
	'dx_des', 'dy_des', 'dz_des', 'dw_des', 'dex_des', 'dey_des', 'dez_des',
	'ddx_des', 'ddy_des', 'ddz_des', 'ddw_des', 'ddex_des', 'ddey_des', 'ddez_des',
	'dddx_des', 'dddy_des', 'dddz_des', 'dddw_des', 'dddex_des', 'dddey_des', 'dddez_des',

	'e_x', 'e_y', 'e_z', 'e_w', 'e_ex', 'e_ey', 'e_ez',
	'de_x', 'de_y', 'de_z', 'de_w', 'de_ex', 'de_ey', 'de_ez',
	'dde_x', 'dde_y', 'dde_z', 'dde_w', 'dde_ex', 'dde_ey', 'dde_ez',
	'ddde_x', 'ddde_y', 'ddde_z', 'ddde_w', 'ddde_ex', 'ddde_ey', 'ddde_ez',	
	
	'q1', 'q2', 'q3', 'q4', 'q5', 'q6',
	'dq1', 'dq2', 'dq3', 'dq4', 'dq5', 'dq6',
	'ddq1', 'ddq2', 'ddq3', 'ddq4', 'ddq5', 'ddq6',

	'q1_des', 'q2_des', 'q3_des', 'q4_des', 'q5_des', 'q6_des',
	'dq1_des', 'dq2_des', 'dq3_des', 'dq4_des', 'dq5_des', 'dq6_des',
	'ddq1_des', 'ddq2_des', 'ddq3_des', 'ddq4_des', 'ddq5_des', 'ddq6_des',

	'KP1', 'KP2', 'KP3', 'KP4', 'KP5', 'KP6',
	'KD1', 'KD2', 'KD3', 'KD4', 'KD5', 'KD6',	

	'u1', 'u2', 'u3', 'u4', 'u5', 'u6',

	'P1', 'P2', 'P3', 'P4', 'P5', 'P6',
	'J1', 'J2', 'J3', 'J4', 'J5', 'J6' 
	]


df = pd.DataFrame(columns=column_names)

# Filename
now = datetime.now()
now = now.strftime("%d%m%Y_%H-%M-%S")
#fn = now
fn = "articular"+"_kp_"+str(KP[0])+"_alpha_"+str(alpha)+"_beta_"+str(beta)+"_gamma_"+str(gamma)+"_t_"+str(t_reach)+".csv"
#fn = "borrar_articular_test"

# Creates folder if it does not exist

if not os.path.exists(folder):
	os.makedirs(folder)

path = os.path.join(folder, fn)
df.to_csv(path, index=False)

while not rospy.is_shutdown():
	# desired values (cartesian space)
	x_des[0:3], dx_des[0:3], ddx_des[0:3], dddx_des[0:3] = circular_trayectory_generator(t)
	
	# reference values (cartesian space)
	x_ref[0:3], dx_ref[0:3], ddx_ref[0:3] = reference_trajectory(x_des[0:3], x_ref[0:3], dx_ref[0:3], dt)

	# Inverse kinematics
	q_des, dq_des, ddq_des, dddq_des = ikine_pose_ur5(x_ref, dx_ref, q_des, dq_des, ddq_des)	# It starts with q_des=copy(q0)

	# Inverse kinematics
	#q_des, dq_des, ddq_des, dddq_des = ikine_pose_ur5(x_des, dx_des, q_des, dq_des, ddq_des)	# It starts with qdes=copy(q0)

	# Error calculation
	e 	=  q_des - q
	de 	=  dq_des - dq
	dde =  ddq_des - ddq

	# Calcular b y M
	#rbdl.NonlinearEffects(modelo, q, dq, b)
	#rbdl.CompositeRigidBodyAlgorithm(modelo, q, M)
	#b_est = UR5_robot.get_b()
	M  	  = UR5_robot.get_M()
	
	# SMC articular + Feedback linearization
	b_est = u - np.dot(M, ddq)  			
	u = M.dot(ddq_des +  np.multiply(KP, e) + np.multiply(KD, de)) + b_est
	
	# Send control signal
	u 		= saturador_effort_control_UR5(u)
	UR5_robot.send_command(u)

	# Read position, velocity, and acceleration angular of UR5 joints
	q  		= UR5_robot.read_joint_positions()
	dq 		= UR5_robot.read_joint_velocities()
	ddq 	= UR5_robot.read_joint_accelerations()

	# Publish message
	jstate.header.stamp = rospy.Time.now()
	jstate.name 		= jnames			# Joints position name
	jstate.position 	= q
	jstate.velocity 	= dq
	pub.publish(jstate)


	# Current position and velocity of UR5 end-effector
	x_act[0:7]  = get_current_pose(q)
	dx_act[0:7] = get_current_dpose(q, dq)	

	# Estimation of current acceleration and jerk of UR5 end-effector 
	ddx_act     = (dx_act - dx_act_p)/dt 
	dddx_act    = (ddx_act - ddx_act_p)/dt
	
	# Past values
	dx_act_p 	= copy(dx_act) 
	ddx_act_p   = copy(ddx_act)

	# Error in position, velocity and acceleration 
	x_e[0:7]   = compute_error_pose(x_des, x_act)
	dx_e[0:7]  = compute_error_dpose(dx_des, dx_act)
	ddx_e[0:7] = compute_error_ddpose(ddx_des, ddx_act)
	dddx_e[0:7]= compute_error_dddpose(dddx_des, dddx_act)

	# Derivative of Kp and Kd
	dKP = -(alpha/dt) * (dJ_KP)
	dKD = -(alpha/dt) * (dJ_KD)

	# special parameters
	P1 = +np.multiply(KP, e) + np.multiply(KD, de)
	P2 = -np.multiply(dKP,e)   - np.multiply(KP, de) -\
		  np.multiply(dKD, de) - np.multiply(KD, dde)
	
	#cost function
	c = gamma *0.5*np.dot(P1.transpose(),P1) + beta*0.5*np.dot(P2.transpose(),P2) 	# [6x1]
	
	# Gradient descent
	dP1_q = -copy(KP) 					# [6x1]
	dP2_q = +copy(dKP) 					# [6x1]

	# partial derivative of J (cost) with respecto to q(output)
	dJ_q  = gamma*np.multiply(P1, dP1_q) + beta*np.multiply(P2, dP2_q)	# [6x1]
	
	# partial derivative of q (output) with respect to u (control)
	nonzero = (u!=up) 	# to avoid problems when du=0
	du = (u-up)*nonzero
	dq_du = np.sign(np.multiply(dq, du))
	
	# partial derivative of u (control) with respect to k (control gain)
	du_KP = np.dot(M, e)				# [6x1]
	du_KD = np.dot(M, de)   			# [6x1]

	# gradient with respecto to each control gain
	dJ_KP = np.multiply(np.multiply(dJ_q, dq_du), du_KP) 	# [6x1]
	dJ_KD = np.multiply(np.multiply(dJ_q, dq_du), du_KD) 	# [6x1]	

	# New value of KP and KD
	crit_p = (1000)*np.sqrt(np.sum(np.power(x_e[0:3],2))) 	 # [mm]
	crit_a = (180/np.pi)*np.sqrt(np.sum(np.power(e[0:6],2))) # [Â°]
	
	# Upgrade control gains
	KP[0:6] = KP[0:6] - alpha*dJ_KP[0:6] 	#[6x1]  
	KD[0:6] = KD[0:6] - alpha*dJ_KD[0:6] 	#[6x1]	

	# Ball marker
	bmarker_des.xyz(x_ref[0:3])	# Green
	bmarker_act.xyz(x_act[0:3])	# Yellow
	
	# Print
	print("t: ", np.round(t,2))
	print("du; ", dq_du)
	print("KP: ", KP)
	print("KD: ", KD) 
	print("c:  ", c)
	print("crit_p: ", crit_p)
	print("crit_a: ", crit_a)
	#print("e   (mm): ", np.round(1000*x_e[0:3], 1))
	#print("de  (mm): ", np.round(1000*dx_e[0:3],1))
	#print("dde (mm): ", np.round(1000*ddx_e[0:3],1))
	#print("ddde(mm): ", np.round(1000*dddx_e[0:3],1))	
	print("\n")

	# Append data
	row = tl(x_act)+tl(dx_act)+tl(ddx_act)+tl(dddx_act)+\
		  tl(x_des)+tl(dx_des)+tl(ddx_des)+tl(dddx_des)+\
		  tl(x_e)+tl(dx_e)+tl(ddx_e)+tl(dddx_e)+\
		  tl(q)+tl(dq)+tl(ddq)+\
		  tl(q_des)+tl(dq_des)+tl(ddq_des)+\
		  tl(KP)+\
		  tl(KD)+\
		  tl(u)+\
		  tl(P1)+\
		  tl(P2)	

	row = tl(np.expand_dims(np.array(row), axis = 1))

	# Fix for redimensionality
	df_row = pd.DataFrame.from_dict(dict(zip(column_names, row)))

	df.append(df_row, sort = False).to_csv(path, index=False, mode = 'a', header=False)

	# Update
	t = t + dt
	up = copy(u)

	if t>=(t_reach): # 10 min
		print("Reached maximum of steps")
		break

	# Wait for the next iteration
	rate.sleep()

print('out because ctrl + c. Data saved.')


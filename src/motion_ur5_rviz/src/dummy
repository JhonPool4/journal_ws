#!/usr/bin/env python

# ============================================================
#    Curso   :   Concytec - UTEC
#     Alumno  :   Jhon Charaja
#     Info    :    articular PD controller with optimal adaptation 
#                in terms of position and jerk error.
"""
    Notes:
    -----
    - tracking error close to 0
    - system is stable with disturbance 0.95*b and try to reduce tracking error (regular)
    - system is stable with disturbance 0.90*M and reduce tracking error (fast)
    - system is stable with disturbance 0.10*M and reduce tracking error
    - for high disturbances I recommend to use gamma >=0.9
    Updates:
    -------
    - new library to compute dynamic model (pinocchio)
    - new represention of orientation (axis/angle)
    - 
"""
# ============================================================

# ============================
#             Libraries
# ============================ 
import rospy                             # ROS with Python
import os                                 # Manipulate path names
import pandas as pd                     # Save data
from sensor_msgs.msg import JointState     # To send angular position to robot
from labpythonlib.lab_functions import *
from labpythonlib.lab_markers import *    

from utils.kalman import *
from utils.datareader import *

# =============
#     Save data
# =============
origin     = '../data/PDi'
file_name     = 'circular_traj'
pwd = os.path.dirname(os.path.realpath(__file__))
folder = os.path.join(pwd, origin, file_name)


origin_assets = '../assets'
folder_assets = os.path.join(pwd, origin_assets)

# Creates folder if it does not exist
if not os.path.exists(folder):
    os.makedirs(folder)

column_names = [
    't',
    'q1_med', 'q2_med', 'q3_med', 'q4_med', 'q5_med', 'q6_med',
    'dq1_med', 'dq2_med', 'dq3_med', 'dq4_med', 'dq5_med', 'dq6_med',
    'ddq1_med', 'ddq2_med', 'ddq3_med', 'ddq4_med', 'ddq5_med', 'ddq6_med',

    'q1_ref', 'q2_ref', 'q3_ref', 'q4_ref', 'q5_ref', 'q6_ref',
    'dq1_ref', 'dq2_ref', 'dq3_ref', 'dq4_ref', 'dq5_ref', 'dq6_ref',
    'ddq1_ref', 'ddq2_ref', 'ddq3_ref', 'ddq4_ref', 'ddq5_ref', 'ddq6_ref',

    'KP1', 'KP2', 'KP3', 'KP4', 'KP5', 'KP6',
    'KD1', 'KD2', 'KD3', 'KD4', 'KD5', 'KD6',

    'u1', 'u2', 'u3', 'u4', 'u5', 'u6',

    'J1', 'J2', 'J3', 'J4', 'J5', 'J6'
    ]

df = pd.DataFrame(columns=column_names,dtype=object)


# ===============================
#         Configuration of node
# ===============================
# Create a nodo: PD_controller
rospy.init_node("dummy")
# Public in topic /joint_states    to send joint data        
pub = rospy.Publisher('joint_states', JointState, queue_size=1000)
# Loop rate (in Hz)


dt         = 0.033                    # 10  [ms]
rate     = rospy.Rate(1/dt)        # 100 [Hz]
# object(message) type JointState
jstate = JointState()

# ===============================
#         Line and Ball Marker
# ===============================
# Show a ball marker for current and desired position of robot' end-effector
bmarker_des     = BallMarker(color['GREEN'])


# ================================
#         Dataset Trajectory
# ================================
dataset_used = True

if dataset_used:
    dataset_type = "jigsaw" # jigsaw or desk
    fn = "Suturing_B001.txt"
    dataset_path = os.path.join(folder_assets, dataset_type, fn)
    dr = DataReaderJIGSAW(dataset_path)
    dr.read_dataset()
    dr.calculate()

# =======================================
#     Set home joint configuration of UR5
# =======================================
#  Home joint configuration of ur5 robot (radians)
#q0 = np.array([-0.22007212, -0.72670633, -4.72730825,  0.7416256,   1.57079633, -3.36166477]) # Center [0.5 +0.0 0.0]
q0 = np.array([ 0.35957749, -1.19879333, -4.81902357,  2.68479446,  2.25581278,  0.14631292]) # Initial joint conf for dataset

dq0 = np.zeros(6)
ddq0 = np.zeros(6)
ddq0 = np.zeros(6) 
# reference trajectory: position, velocity and acceleration
q_ref =   copy(q0)
dq_ref =  np.zeros(6) 
ddq_ref = np.zeros(6) 
dddq_ref = np.zeros(6)
# measured trajectory: position, velocity and acceleration
q_med =   copy(q0)
dq_med =  np.zeros(6) 
ddq_med = np.zeros(6) 
ddq_med = np.zeros(6)
# error trajectory: position, velocity and acceleration
q_e = np.zeros(6)
dq_e =  np.zeros(6) 
ddq_e = np.zeros(6) 
ddq_e = np.zeros(6)


# ===========================
#   UR5 robot configuration
# ===========================
# joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']
# real model of ur5 robot (with uncertainty)
real_urdf_path = rospy.get_param('/real_ur5_urdf')
# nominal model of ur5 robot  
nomi_urdf_path = rospy.get_param('/nominal_ur5_urdf')
# the class robot loads labs_ur5.urdf
real_robot = Robot(q0, dq0, dt, real_urdf_path)
nomi_robot = Robot(q0, dq0, dt, nomi_urdf_path)
# number of degress of freedom
ndof = real_robot.ndof

# create inertia matrix 
M = np.zeros([ndof,ndof])
M_p = np.zeros([6,6])
# create nonlinear effects vector
b = np.zeros(ndof)
b_p = np.zeros(6)



# ==============================================
#   set initial cartesian configuration of UR5
# ==============================================
# initial cartesian configuration: position, velocity and acceleration
p0 = np.zeros(3)
rpy0 = np.zeros(3)
p0, R0 = real_robot.forward_kinematics(q0)
rpy0 = rot2rpy(R0)

dp0 = np.zeros(3)
w0  = np.zeros(3)
dp0, w0 = real_robot.twist(q0, dq0)

ddp0 = np.zeros(3)
dw0 = np.zeros(3)
ddp0, dw0 = real_robot.dtwist(q0, dq0, ddq0)

dddp0 = np.zeros(3) # requires estimation tecnique

# desired cartesian trajectory: position, velocity and acceleration
p_des = np.zeros(3) # will be modified in "while loop"
rpy_des = np.zeros(3)
R_des = np.array([[0, 0, 1],[0, 1, 0],[-1, 0, 0]]) # enf-effefor with direction towards negativa z-axis 
rpy_des = rot2rpy(R_des)

dp_des = np.zeros(3) # will be modified in "while loop"
w0_des = np.zeros(3)

ddp_des = np.zeros(3) # will be modified in "while loop"
dw0_des = np.zeros(3)

dddp_des = np.zeros(3) # will be modified in "while loop"

# reference cartesian trajectory: position, velocity and acceleration
p_ref = copy(p0)
rpy_ref = copy(rpy0)
drpy_ref = np.zeros(3)
ddrpy_ref = np.zeros(3)

dp_ref = copy(dp0)
w_ref = copy(w0)

ddp_ref = copy(ddp0)
dw_ref = copy(dw0)

dddp_ref = copy(dddp0)

# measured cartesian trajectory: position, velocity and acceleration
p_med = copy(p0)
R_med = copy(R0)
rpy_med = copy(rpy0)

dp_med = copy(dp0)
w_med = copy(w0)

ddp_med = copy(ddp0)
dw_med = copy(dw0)

dddp_med = np.zeros(3)

# Cartesian error
p_e    = np.zeros(6)
dp_e   = np.zeros(6)
ddp_e  = np.zeros(6)
dddp_e = np.zeros(6)

# temporal variables
axis_angle_med = np.zeros(3)
axis_angle_ref = np.zeros(3)

# ================================
#             PD controller
# ================================
alpha = 0.1 # 10 50 80
gamma = 0.9
beta  = 0.1
KP    = np.array([9, 9, 9, 9, 9, 9])
KD    = np.array([6, 6, 6, 6, 6, 6])
dJ_KP = np.zeros(6)
dJ_KD = np.zeros(6)
dKP = np.zeros(6)
dKD = np.zeros(6)

u  = np.zeros(6)
up = np.zeros(6)

# ================================
#         Dynamic simulation
# ================================
t = 0.0
t_reach = 60 # secs

"""
x = np.array([0.5, 0.0, 0.0])
R = copy(R_des)
q = real_robot.inverse_kinematics_pose(x, R, q0)

print("q: ", q)
print("x: ", real_robot.forward_kinematics(q))
"""

q0_ref = copy(q0)
q0_des = copy(q0)

while not rospy.is_shutdown():
    # desired values (cartesian space)
    if not dataset_used:
        p_des, dp_des, ddp_des, dddp_des = circular_trayectory_generator(t)
        rpy_des = rot2rpy(R_des)

    else:
        x_des, dx_des, ddx_dex, dddx_des = dr.dataset_trajectory_generator()
        p_des = x_des[0:3]
        rpy_des = x_des[3:6]
        R_des = rpy2rot(rpy_des)
    
    # reference values (cartesian space)
    p_ref, dp_ref, ddp_ref = reference_trajectory(p_des, p_ref, dp_ref, dt)
    rpy_ref, drpy_ref, ddrpy_ref = reference_trajectory(rpy_des, rpy_ref, drpy_ref, dt)
    R_ref = rpy2rot(rpy_ref)

    # Inverse kinematics
    q_ref = real_robot.inverse_kinematics_pose(p_ref, R_ref, q0_ref)    # It starts with q_ref=copy(q0)
    q_des = real_robot.inverse_kinematics_pose(p_des, R_des, q0_des)    # It starts with q_ref=copy(q0)
    
    # Publish message
    jstate.header.stamp = rospy.Time.now()
    jstate.name         = jnames            # Joints position name
    jstate.position     = q_des
    jstate.velocity     = dq0
    pub.publish(jstate)

    q0_des = q_des
    q0_ref = q_ref

    # Ball marker
    bmarker_des.xyz(p_ref[0:3])    # Green

 

    # Print
    print("t: ", np.round(t,2))
    #print("crit_p: ", crit_p)
    #print("crit_a: ", crit_a)
    print("\n")

    # Update
    t = t + dt
    
    if dataset_used:
        if dr.check():
            print("Reached maximum of steps")
            break

    if t>=(t_reach): # 60 sec
        print("Reached maximum of steps")
        break

    # Wait for the next iteration
    rate.sleep()
    
print('out because ctrl + c. Data saved.')


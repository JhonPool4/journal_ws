#!/usr/bin/env python3

# ============================
# 			Libraries
# ============================ 
import rospy 							# ROS with Python
import os 								# Manipulate path names
import pandas as pd 					# Save data
from sensor_msgs.msg import JointState 	# To send angular position to robot
from custom_rviz.msg import CustomMsg
from labpythonlib.lab_functions import *
from labpythonlib.lab_markers import *	


# =============
#   Save data
# =============

data_dir   = rospy.get_param('/node/data_path')
images_dir = rospy.get_param('/node/image_path')
videos_dir = rospy.get_param('/node/video_path')
pwd = os.path.dirname(os.path.realpath(__file__))

origin_assets = '../assets'
folder_assets = os.path.join(pwd, origin_assets)
"""
# Creates folder_data if it does not exist
if not os.path.exists(data_dir):
	os.makedirs(data_dir)
if not os.path.exists(images_dir):
	os.makedirs(images_dir)
if not os.path.exists(videos_dir):
	os.makedirs(videos_dir)
"""

column_tmp = [
    't',
    'x_des', 'y_des', 'z_des', 'roll_des', 'pitch_des', 'yaw_des',
    'dx_des', 'dy_des', 'dz_des', 'droll_des', 'dpitch_des', 'dyaw_des',
    'x_ref', 'y_ref', 'z_ref', 'roll_ref', 'pitch_ref', 'yaw_ref',
    'dx_ref', 'dy_ref', 'dz_ref', 'droll_ref', 'dpitch_ref', 'dyaw_ref',    
    ]
#    'ddx_des', 'ddy_des', 'ddz_des', 'ddroll_des', 'ddpitch_des', 'ddyaw_des',

df_tmp = pd.DataFrame(columns=column_tmp,dtype=object)
path_tmp = os.path.join(pwd, 'tmp2.csv')
df_tmp.to_csv(path_tmp, index=False)

# ===============================
# 		Configuration of node
# ===============================
# create a nodo: PD_controller
rospy.init_node("node")
# publishers	
pub_jstate = rospy.Publisher('joint_states', JointState, queue_size=100)
pub_simdata = rospy.Publisher('simulation_data', CustomMsg, queue_size=100)
# object(message)
jstate = JointState()
simdata = CustomMsg()

# Loop rate (in Hz)
freq = 30.0
dt = 1/freq                    # 33  [ms]
rate = rospy.Rate(freq)        # 100 [Hz]

# =========================
#   Ball and Frame Marker   
# =========================
# Show a ball marker for current and desired position of robot' end-effector
bmarker_ref = BallMarker(color['GREEN'], alpha=0.5)
bmarker_act = BallMarker(color['YELLOW'])
fmarker_ref = FrameMarker(xyz_pos=[0.5, 0, 0], alpha=0.5)
fmarker_act = FrameMarker(xyz_pos=[0.5, 0, 0], alpha=1)


# ==============
#   Trajectory  
# ==============
trajectory_type = rospy.get_param('/node/trajectory')

if  trajectory_type.split('_')[0] == 'dataset' and int(trajectory_type.split('_')[1]) in range(1,5):
    datasets = [ 
    'Needle_Passing_E004.txt', #s
    'Knot_Tying_E003.txt', #s
    'Knot_Tying_D001.txt', #s
    'Knot_Tying_D003.txt'] #s

    arms = [
            "l",#s
            "r",#s
            "l",#s
            "r",#s
            ]
            
    dataset_number = int(trajectory_type.split('_')[1]) - 1

    fn = datasets[dataset_number]  
    is_right_arm = True if arms[dataset_number] == 'r' else False    
    dataset_folder = "dataset" 

    dataset_path = os.path.join(folder_assets, dataset_folder, fn)

    dr = DataReader(dataset_path)
    dr.read_dataset(is_right_arm)
    dr.calculate()
    dataset_used = True

elif trajectory_type == 'circular':
    dataset_used = False
else:
    raise ValueError('Trajectory type {} is not valid. Choose only "circular" or "dataset_x [x: 1,2,3,4]".'.format(trajectory_type))

# =======================================
# 	Set home joint configuration of UR5
# =======================================
if dataset_used:

    
    x0, dx0,_,_ = dr.dataset_trajectory_generator()
else:
    x0, dx0 = circular_trayectory_generator(0) 
    #q0 = np.array([-0.22007212, -0.72670633, -4.72730825,  0.7416256,   1.57079633, -3.36166477]) # Center [0.5 +0.0 0.0]
# real model
tmp_urdf_path = rospy.get_param('/real_ur5_urdf')
robot_tmp = Robot(np.zeros(6), np.zeros(6), dt, tmp_urdf_path)

q0 = robot_tmp.inverse_kinematics_pose(x0[0:3], rpy2rot(x0[3:6]), np.zeros(6), max_iter = 500) # Initial joint conf for dataset
q0 = np.arctan2(np.sin(q0), np.cos(q0)) # normalization
dq0 = np.zeros(6)
ddq0 = np.zeros(6)
# reference trajectory: position, velocity and acceleration
q_ref = copy(q0)
# measured trajectory: position, velocity and acceleration
q_med = copy(q0)
dq_med = copy(dq0)

# create kalman derivators
kf_pos = MultipleKalmanDerivator(dt, x0[0:3], dx0[0:3], np.zeros(3), n_obs=2, sigmaR=1e-3,sigmaQ=1)
kf_ori = MultipleKalmanDerivator(dt, x0[3:6], dx0[3:6], np.zeros(3), n_obs=2, sigmaR=1e-3,sigmaQ=1)
kalman_jerror = False

# ===========================
#   UR5 robot configuration
# ===========================
# joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']
# real model of ur5 robot (with uncertainty)
real_urdf_path = rospy.get_param('/real_ur5_urdf')
# nominal model of ur5 robot  
nomi_urdf_path = rospy.get_param('/nominal_ur5_urdf')
# the class robot loads labs_ur5.urdf
real_robot = Robot(q0, dq0, dt, real_urdf_path)
nomi_robot = Robot(q0, dq0, dt, nomi_urdf_path)
# number of degress of freedom
ndof = real_robot.ndof

# create inertia matrix 
M = np.zeros([ndof,ndof])
M_p = np.zeros([6,6])
# create nonlinear effects vector
b = np.zeros(ndof)
b_p = np.zeros(6)


# ==============================================
#   set initial cartesian configuration of UR5
# ==============================================
# initial cartesian configuration: position, velocity and acceleration
p0, R0 = real_robot.forward_kinematics(q0)
rpy0 = rot2rpy(R0)

dp0, w0 = real_robot.twist(q0, dq0)
ddp0, dw0 = real_robot.dtwist(q0, dq0, ddq0)

# reference cartesian trajectory: position, velocity and acceleration
p_ref, rpy_ref = copy(p0), copy(rpy0)
dp_ref, drpy_ref = copy(dp0), np.zeros(3)

# measured cartesian trajectory: position, velocity and acceleration
p_med, dp_med, ddp_med = copy(p0), copy(dp0), copy(ddp0)

R_med, rpy_med = copy(R0), copy(rpy0)
w_med, dw_med = copy(w0), copy(dw0)


# Cartesian error
x_e    = np.zeros(6)
dx_e   = np.zeros(6)
ddx_e  = np.zeros(6)
dddx_e = np.zeros(6)

# ================================
# 			PD controller
# ================================
alpha = rospy.get_param('/node/alpha')        # 10 15 20  # @param learning rate
gamma = rospy.get_param('/node/gamma') 		# @param hyperparameter for position error reduction
beta  = rospy.get_param('/node/beta') 			# @param hyperparameter for acceleration error reduction 
delta = rospy.get_param('/node/uncertainty')  # @param disturbance porcentage [0 25 50 75 100]
alpha_KP = np.zeros(6)
alpha_KD = np.zeros(6)
alpha_de = np.zeros(6)

KP    = np.array([9, 9, 9, 9, 9, 9])
KD    = 2*np.sqrt(KP)
dJ_KP = np.zeros(6)
dJ_KD = np.zeros(6)
dKP = np.zeros(6)
dKD = np.zeros(6)

F  = np.zeros(6)
Fp = np.zeros(6)
u  = np.zeros(6) 		# @param effort control


# ================================
# 		Dynamic simulation
# ================================
t = 0.0 				# @param current simulation time
sim_time = rospy.get_param('/node/sim_time') 			 # @param maximum simulation time [s]
max_pos_error = rospy.get_param('/node/max_pos_error') # @param maximum position error [mm]
max_ori_error = rospy.get_param('/node/max_ori_error') # @param maximum orientation error [deg]
max_jerk = rospy.get_param('/node/max_jerk') # @param maximum jerk [mm/s^3]


while not rospy.is_shutdown():
    # desired values: pose and dpose
    if not dataset_used:
        x_des, dx_des = circular_trayectory_generator(t) 
    else:
        x_des, dx_des, _, _ = dr.dataset_trajectory_generator()

    # angula velocity
    w_des = rpy2angularVel(x_des[3:6], dx_des[3:6])

    # ==============================
    #   Fist stage: Preprocessing   
    # ==============================
    # reference position at Cartesian space
    p_ref, dp_ref, _ = reference_trajectory(x_des[0:3], x_des[0:3], p_ref, dp_ref, dt)
    
    # reference orientation with Euler angles (ZYX)
    rpy_ref, drpy_ref, _ = reference_trajectory(x_des[3:6], dx_des[3:6], rpy_ref, drpy_ref, dt)

    # smothing reference signal
    #p_ref, dp_ref, ddp_ref  = kf_pos.update(p_ref, dp_ref)
    #rpy_ref, drpy_ref, ddrpy_ref = kf_ori.update(rpy_ref, drpy_ref)
    p_ref, dp_ref, ddp_ref  = kf_pos.update(x_des[0:3], dx_des[0:3])
    rpy_ref, drpy_ref, ddrpy_ref = kf_ori.update(x_des[3:6], dx_des[3:6])

    # ======================================================
    #   Second stage: Orientation and derivatives mapping         
    # ======================================================
    R_ref = rpy2rot(rpy_ref)
    w_ref = rpy2angularVel(rpy_ref, drpy_ref)
    dw_ref = rpy2angularAccel(rpy_ref, drpy_ref, ddrpy_ref)
    # desired enf-effector acceleration
    ddpw_ref = np.concatenate((ddp_ref,dw_ref), axis=0)

    # Cartesian error: position
    x_e[0:3]   =  p_ref - p_med
    dx_e[0:3]  =  dp_ref - dp_med
    ddx_e[0:3] =  ddp_ref - ddp_med

    # Carteisan error: orientation
    x_e[3:6] 	= axisangle_error(R_ref, R_med)
    dx_e[3:6] 	= w_ref - w_med
    ddx_e[3:6]  = dw_ref - dw_med

    # ======================================================
    #   Third stage: Forward and differential kinematicss         
    # ======================================================    
    # jacobian: pose [6x6]
    J = nomi_robot.geometric_jacobian(q_med)  
    # jacobian: damped pseudo-inverse [6x6]
    J_inv = damped_pinv(J)   
    # jacobian: time-derivative [6x6]
    dJ = nomi_robot.geometric_jacobian_time_derivative(q_med, dq_med)

    # computes robot dynamics (Cartesian space)
    M  = pin.crba(nomi_robot.robot.model, real_robot.robot.data, real_robot.q)#nomi_robot.get_M() 
    M_p = damped_pinv(J.dot(np.linalg.inv(M).dot(J.T))) # inertia matrix at Cartesian space

    b = pin.rnea(nomi_robot.robot.model, real_robot.robot.data, real_robot.q, real_robot.dq, np.zeros(ndof))#nomi_robot.get_b() 
    b_p = J_inv.T.dot(b) - M_p.dot(dJ.dot(dq_med)) # nonlinear effects vector at Joint space at Cartesian space

    # cartesian PD control + Feedback linearization
    F = M_p.dot(ddpw_ref + np.multiply(KP, x_e) + np.multiply(KD, dx_e)) + b_p
    u = J.T.dot(F) 

    # send control signal
    real_robot.send_control_command(u)    

    # update states
    #rpy_old = rot2rpy(R_med) 
    q_med, dq_med, _ = real_robot.read_joint_position_velocity_acceleration()
    p_med, dp_med, ddp_med = real_robot.read_cartesian_position_velocity_acceleration()

    R_med = real_robot.read_ee_orientation()
    w_med, dw_med = real_robot.read_ee_angular_velocity_acceleration()
    #rpy_med = rot2rpy_unwrapping(R_med, copy(rpy_med))

    
    # ==============================
    #   Fourth stage: Optimization            
    # ==============================    
    # create kalman filter object to estimate jerk error
    if not kalman_jerror:
        kalman_jerror = True
        kf_jerror = MultipleKalmanDerivator(dt, dx_e, ddx_e, np.zeros(6), n_obs=2, sigmaR=1e-4,sigmaQ=1)
    # estimate jerk error
    _, _, dddx_e = kf_jerror.update(dx_e, ddx_e)
    
    # Derivative of Kp and Kd
    dKP = -(alpha/dt) * (dJ_KP)
    dKD = -(alpha/dt) * (dJ_KD)

    # special parameters
    P1 = np.multiply(KP,x_e) + np.multiply(KD, dx_e)
    P2 = -np.multiply(dKP, x_e)   - np.multiply(KP, dx_e) \
         -np.multiply(dKD, dx_e) - np.multiply(KD, ddx_e)

    #cost function
    c = gamma*0.5*np.dot(P1.T,P1) + beta*0.5*np.dot(P2.T,P2) 	# [1x1]

    # Gradient descent
    dP1_q = -copy(KP)					# [6x1]
    dP2_q = copy(dKP) 					# [6x1]	

    # partial derivative of J (cost) with respecto to q(output)
    dJ_q  = gamma*np.multiply(P1, dP1_q) + beta*np.multiply(P2, dP2_q)	# [6x1]

    # partial derivative of q (output) with respect to u (control)
    dpw_med = np.concatenate((dp_med, w_med), axis=0)
    dF = (F-Fp)#*nonzero
    dq_du = np.sign(np.multiply(dpw_med, dF))

    # partial derivative of u (control) with respect to k (control gain)
    du_KP = np.dot(M_p, x_e)				# [6x1]
    du_KD = np.dot(M_p, dx_e)   			# [6x1]

    # gradient with respecto to each control gain
    dJ_KP = np.multiply(dJ_q, du_KP) 	# [6x1]
    dJ_KD = np.multiply(dJ_q, du_KD) 	# [6x1]	    

    # convergence conditions
    convergence_position = 0.001*max_pos_error*np.ones(3)           # [m]
    convergence_orientation = np.deg2rad(max_ori_error)*np.ones(3)  # [rad]
    convergence_pose = np.concatenate((convergence_position, convergence_orientation), axis=0) # [m, rad]
    crit_p = 1*(abs(x_e)>=convergence_pose)

    convergence_jerk = 0.001 * max_jerk * np.ones(6)
    crit_j = 1*(abs(dddx_e)>=convergence_jerk)    

    # new learning rate
    alpha_de[0] = alpha*update_learning_rate(abs(1000*dx_e[0]), x_min=3, x_max=20, y_min=0)
    alpha_de[1] = alpha*update_learning_rate(abs(1000*dx_e[1]), x_min=3, x_max=20, y_min=0)
    alpha_de[2] = alpha*update_learning_rate(abs(1000*dx_e[2]), x_min=3, x_max=20, y_min=0)
    alpha_de[3] = alpha*update_learning_rate(abs(np.rad2deg(dx_e[3])), x_min=3, x_max=20, y_min=0)
    alpha_de[4] = alpha*update_learning_rate(abs(np.rad2deg(dx_e[4])), x_min=3, x_max=20, y_min=0)
    alpha_de[5] = alpha*update_learning_rate(abs(np.rad2deg(dx_e[5])), x_min=3, x_max=20, y_min=0)    


    # Upgrade control gains
    KP = KP - alpha_de*crit_p*crit_j*dJ_KP 	#[6x1]  
    KD = KD - alpha_de*crit_p*crit_j*dJ_KD 	#[6x1]	

    # ======================
    # Publish on topics     
    # ======================
    # Publish message: joint states
    jstate.header.stamp = rospy.Time.now()
    jstate.name 		= jnames			# Joints position name
    jstate.position 	= q_med
    jstate.velocity 	= dq_med
    pub_jstate.publish(jstate)
    # Publish message: simulation data
    simdata.time = t
    simdata.x_e = np.concatenate((1000*x_e[0:3], np.rad2deg(x_e[3:6])), axis=0)
    simdata.dx_e = np.concatenate((1000*dx_e[0:3], np.rad2deg(dx_e[3:6])), axis=0)
    simdata.dddx_e = np.concatenate((1000*dddx_e[0:3], np.rad2deg(dddx_e[3:6])), axis=0)
    simdata.q = q_med
    simdata.u = u
    simdata.alpha = alpha_de
    pub_simdata.publish(simdata)

    # Ball marker
    bmarker_ref.xyz(p_ref[0:3])	# Green
    bmarker_act.xyz(p_med[0:3])	# Yellow          
    bmarker_ref.publish()
    bmarker_act.publish()    
    # Frame marker
    fmarker_ref.xyz(p_ref[0:3]) 
    fmarker_act.xyz(p_med[0:3])
    fmarker_ref.rotation(R_ref) 
    fmarker_act.rotation(R_med)
    fmarker_ref.publish()
    fmarker_act.publish()    
    """
    row_tmp = tl(x_des)+tl(dx_des)+tl(dp_ref)+tl(drpy_ref)+tl(dp_med)+tl(drpy_med)
    row_tmp = tl(np.expand_dims(np.array(row_tmp), axis = 1))
    df_row_tmp = pd.DataFrame.from_dict(dict(zip(column_tmp, row_tmp)))
    df_tmp.append(df_row_tmp, sort = False).to_csv(path_tmp, index=False, mode = 'a', header=False)
    """
    # Update
    t = t + dt


    if t>=(sim_time): # 60 sec
        print("Reached maximum of steps")
        break

    # Wait for the next iteration
    rate.sleep()

print('out because ctrl + c. Data saved.')              
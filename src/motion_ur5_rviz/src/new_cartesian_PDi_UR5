#!/usr/bin/env python

"""
Useful commands:
----------------
    - xacro file.xacro > file.urdf
    - roslaunch motion_ur5_rviz new_cartesian_PDi_UR5.launch 
        trajectory:=circular
        exp=exp1
        uncertainty:=100 
        alpha:=0 
        sim_time:=100 
        record_rosbag:=true 
        

Updates:
--------
	- (working) new formulation of dq/du and du/dK 
    - (developing) new uncertainty test: 
        - nomi_robot: urdf model with nominal weights of ur5 links (factory values)
        - real_robot: urdf model with new weights of ur5 sixth link (25%, 50%, 75%, 100%)
        - control and optimization equations should use "nomi_robot" just state update should use
          "real_robot"  
"""

# ============================
# 			Libraries
# ============================ 
import rospy 							# ROS with Python
import os 								# Manipulate path names
import pandas as pd 					# Save data
from sensor_msgs.msg import JointState 	# To send angular position to robot

from labpythonlib.lab_functions import *
from labpythonlib.lab_markers import *	
from utils.kalman import *
from utils.datareader import *



# =============
# 	Save data
# =============
data_dir   = rospy.get_param('/pd_node/data_path')
images_dir = rospy.get_param('/pd_node/image_path')
videos_dir = rospy.get_param('/pd_node/video_path')
pwd = os.path.dirname(os.path.realpath(__file__))

origin_assets = '../assets'
folder_assets = os.path.join(pwd, origin_assets)

# Creates folder_data if it does not exist
if not os.path.exists(data_dir):
	os.makedirs(data_dir)
if not os.path.exists(images_dir):
	os.makedirs(images_dir)
if not os.path.exists(videos_dir):
	os.makedirs(videos_dir)


column_names = [
	't',

	'x_med', 'y_med', 'z_med',
	'dx_med', 'dy_med', 'dz_med',	
	'ddx_med', 'ddy_med', 'ddz_med',
	'dddx_med', 'dddy_med', 'dddz_med',

	'x_ref', 'y_ref', 'z_ref',
	'dx_ref', 'dy_ref', 'dz_ref',
	'ddx_ref', 'ddy_ref', 'ddz_ref',
	'dddx_ref', 'dddy_ref', 'dddz_ref',

    'roll_med', 'pitch_med', 'yaw_med',
	'roll_ref', 'pitch_ref', 'yaw_ref',
	'roll_e', 'pitch_e', 'yaw_e',

	'q1_med', 'q2_med', 'q3_med', 'q4_med', 'q5_med', 'q6_med',
	'dq1_med', 'dq2_med', 'dq3_med', 'dq4_med', 'dq5_med', 'dq6_med',
	'ddq1_med', 'ddq2_med', 'ddq3_med', 'ddq4_med', 'ddq5_med', 'ddq6_med',

	'q1_ref', 'q2_ref', 'q3_ref', 'q4_ref', 'q5_ref', 'q6_ref',
	'dq1_ref', 'dq2_ref', 'dq3_ref', 'dq4_ref', 'dq5_ref', 'dq6_ref',
	'ddq1_ref', 'ddq2_ref', 'ddq3_ref', 'ddq4_ref', 'ddq5_ref', 'ddq6_ref',

	'KP1', 'KP2', 'KP3', 'KP4', 'KP5', 'KP6',
	'KD1', 'KD2', 'KD3', 'KD4', 'KD5', 'KD6',

	'u1', 'u2', 'u3', 'u4', 'u5', 'u6',

	'J'
	]

column_tmp = [
	'dp_e_1', 'dp_e_2', 'dp_e_3', 'dp_e_4', 'dp_e_5', 'dp_e_6',
    'ddp_e_1', 'ddp_e_2', 'ddp_e_3', 'ddp_e_4', 'ddp_e_5', 'ddp_e_6',
    'dp_e_1_kf', 'dp_e_2_kf', 'dp_e_3_kf', 'dp_e_4_kf', 'dp_e_5_kf', 'dp_e_6_kf',
    'ddp_e_1_kf', 'ddp_e_2_kf', 'ddp_e_3_kf', 'ddp_e_4_kf', 'ddp_e_5_kf', 'ddp_e_6_kf',
    'dddp_e_1_kf', 'dddp_e_2_kf', 'dddp_e_3_kf', 'dddp_e_4_kf', 'dddp_e_5_kf', 'dddp_e_6_kf',
    'x_ref', 'y_ref', 'z_ref',
	'dx_ref', 'dy_ref', 'dz_ref',
	'ddx_ref', 'ddy_ref', 'ddz_ref',
	'dddx_ref', 'dddy_ref', 'dddz_ref',
    'x_des', 'y_des', 'z_des',
	'dx_des', 'dy_des', 'dz_des',
	'ddx_des', 'ddy_des', 'ddz_des'
	]

df = pd.DataFrame(columns=column_names,dtype=object)
df_tmp = pd.DataFrame(columns=column_tmp,dtype=object)

# ===============================
# 		Configuration of node
# ===============================
# Create a nodo: PD_controller
rospy.init_node("pd_node")
# Public in topic /joint_states	to send joint data		
pub = rospy.Publisher('joint_states', JointState, queue_size=1000)
# Loop rate (in Hz)
freq = 30.0
dt         = 1/freq                    # 33  [ms]
rate     = rospy.Rate(freq)        # 100 [Hz]
# object(message) type JointState
jstate = JointState()

# ===============================
# 		Line and Ball Marker
# ===============================
# Show a ball marker for current and desired position of robot' end-effector
bmarker_des 	= BallMarker(color['GREEN'])
bmarker_act  	= BallMarker(color['YELLOW'])
amarker_ref     = FrameMarker()
# ================================
# 		    Trajectory
# ================================

trajectory_type = rospy.get_param('/pd_node/trajectory')

if  trajectory_type.split('_')[0] == 'dataset' and \
    trajectory_type.split('_')[1] in str(range(1,5)):

    datasets = [ 
    'Needle_Passing_E004.txt', #s
    'Knot_Tying_E003.txt', #s
    'Knot_Tying_D001.txt', #s
    'Knot_Tying_D003.txt'] #s

    arms = [
            "l",#s
            "r",#s
            "l",#s
            "r",#s
            ]
            
    dataset_number = int(trajectory_type.split('_')[1]) - 1

    fn = datasets[dataset_number]  
    is_right_arm = True if arms[dataset_number] == 'r' else False    
    dataset_folder = "dataset" 

    dataset_path = os.path.join(folder_assets, dataset_folder, fn)

    dr = DataReader(dataset_path)
    dr.read_dataset(is_right_arm)
    dr.calculate()
    dataset_used = True

elif trajectory_type == 'circular':
    dataset_used = False
else:
    raise ValueError('Trajectory type {} is not valid. Choose only "circular" or "dataset_x [x: 1,2,3,4]".'.format(trajectory_type))

# =======================================
# 	Set home joint configuration of UR5
# =======================================
if dataset_used:
    # real model
    tmp_urdf_path = rospy.get_param('/real_ur5_urdf')
    robot_tmp = Robot(np.zeros(6), np.zeros(6), dt, tmp_urdf_path)
    
    x0, _,_,_ = dr.dataset_trajectory_generator()
    p0 = x0[0:3]
    rpy0 = x0[3:6]

    q0 = robot_tmp.inverse_kinematics_pose(p0, rpy2rot(rpy0), np.zeros(6), max_iter = 300) # Initial joint conf for dataset
    q0 = np.arctan2(np.sin(q0), np.cos(q0))
else:
    q0 = np.array([-0.22007212, -0.72670633, -4.72730825,  0.7416256,   1.57079633, -3.36166477]) # Center [0.5 +0.0 0.0]

dq0 = np.zeros(6)
ddq0 = np.zeros(6)
dddq0 = np.zeros(6) 
# reference trajectory: position, velocity and acceleration
q_ref =   copy(q0)
dq_ref =  np.zeros(6) 
ddq_ref = np.zeros(6) 
dddq_ref = np.zeros(6)
# measured trajectory: position, velocity and acceleration
q_med =   copy(q0)
dq_med =  np.zeros(6) 
ddq_med = np.zeros(6) 
dddq_med = np.zeros(6)
# error trajectory: position, velocity and acceleration
q_e = np.zeros(6)
dq_e =  np.zeros(6) 
ddq_e = np.zeros(6) 
dddq_e = np.zeros(6)

# ===========================
#   Jerk estimator: Kalman
# ===========================
dpw_med0 = np.zeros(6)
ddpdw_med0 = np.zeros(6)
dddpddw_med0 = np.zeros(6)

kf = MultipleKalmanDerivator(dt, ndof=6)
kf.initialize(dpw_med0, ddpdw_med0, dddpddw_med0)

# Additional kalman filter
kf_p_ref = MultipleKalmanDerivator(dt, ndof=3, sigmaQ=1e-1,sigmaR=1e-1 )
kf_rpy_ref = MultipleKalmanDerivator(dt, ndof=3, sigmaQ=1e-1,sigmaR=1e-1)

# ===========================
#   UR5 robot configuration
# ===========================
# joints name of UR5 robot
jnames = ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint','wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint']
# real model of ur5 robot (with uncertainty)
real_urdf_path = rospy.get_param('/real_ur5_urdf')
# nominal model of ur5 robot  
nomi_urdf_path = rospy.get_param('/nominal_ur5_urdf')
# the class robot loads labs_ur5.urdf
real_robot = Robot(q0, dq0, dt, real_urdf_path)
nomi_robot = Robot(q0, dq0, dt, nomi_urdf_path)
# number of degress of freedom
ndof = real_robot.ndof

# create inertia matrix 
M = np.zeros([ndof,ndof])
M_p = np.zeros([6,6])
# create nonlinear effects vector
b = np.zeros(ndof)
b_p = np.zeros(6)

# ==============================================
#   set initial cartesian configuration of UR5
# ==============================================
# initial cartesian configuration: position, velocity and acceleration
p0 = np.zeros(3)
rpy0 = np.zeros(3)
p0, R0 = real_robot.forward_kinematics(q0)
rpy0 = rot2rpy(R0)

dp0 = np.zeros(3)
w0  = np.zeros(3)
dp0, w0 = real_robot.twist(q0, dq0)

ddp0 = np.zeros(3)
dw0 = np.zeros(3)
ddp0, dw0 = real_robot.dtwist(q0, dq0, ddq0)

dddp0 = np.zeros(3) # requires estimation tecnique

# desired cartesian trajectory: position, velocity and acceleration
p_des = np.zeros(3) # will be modified in "while loop"
rpy_des = np.zeros(3)
R_des = np.array([[0, 0, 1],[0, 1, 0],[-1, 0, 0]]) # enf-effefor with direction towards negativa z-axis 
rpy_des = rot2rpy(R_des)

dp_des = np.zeros(3) # will be modified in "while loop"
w0_des = np.zeros(3)

ddp_des = np.zeros(3) # will be modified in "while loop"
dw0_des = np.zeros(3)

dddp_des = np.zeros(3) # will be modified in "while loop"

# reference cartesian trajectory: position, velocity and acceleration
p_ref = copy(p0)
rpy_ref = copy(rpy0)
drpy_ref = np.zeros(3)
ddrpy_ref = np.zeros(3)

dp_ref = copy(dp0)
w_ref = copy(w0)

ddp_ref = copy(ddp0)
dw_ref = copy(dw0)

dddp_ref = copy(dddp0)

# measured cartesian trajectory: position, velocity and acceleration
p_med = copy(p0)
R_med = copy(R0)
rpy_med = copy(rpy0)

dp_med = copy(dp0)
w_med = copy(w0)

ddp_med = copy(ddp0)
dw_med = copy(dw0)

dddp_med = np.zeros(3)

# Cartesian error
p_e    = np.zeros(6)
dp_e   = np.zeros(6)
ddp_e  = np.zeros(6)
dddp_e = np.zeros(6)

# temporal variables
axis_angle_med = np.zeros(3)
axis_angle_ref = np.zeros(3)

# ================================
# 			PD controller
# ================================
alpha = rospy.get_param('/pd_node/alpha')        # 10 15 20  # @param learning rate
gamma = rospy.get_param('/pd_node/gamma') 		# @param hyperparameter for position error reduction
beta  = rospy.get_param('/pd_node/beta') 			# @param hyperparameter for acceleration error reduction 
delta = rospy.get_param('/pd_node/uncertainty')  # @param disturbance porcentage [0 25 50 75 100]

KP    = np.array([9, 9, 9, 9, 9, 9])
KD    = 2*np.sqrt(KP)
dJ_KP = np.zeros(6)
dJ_KD = np.zeros(6)
dKP = np.zeros(6)
dKD = np.zeros(6)

F  = np.zeros(6)
Fp = np.zeros(6)
u  = np.zeros(6) 		# @param effort control

# ================================
# 		Dynamic simulation
# ================================
t = 0.0 				# @param current simulation time
sim_time = rospy.get_param('/pd_node/sim_time') 			 # @param maximum simulation time [s]
max_pos_error = rospy.get_param('/pd_node/max_pos_error') # @param maximum position error [mm]
max_ori_error = rospy.get_param('/pd_node/max_ori_error') # @param maximum orientation error [deg]
max_jerk = rospy.get_param('/pd_node/max_jerk') # @param maximum jerk [mm/s^3]


# Filename
fn = "cartesian"+"_KP_"+str(KP[0])+"_KD_"+str(KD[0])+"_alpha_"+str(alpha)+"_beta_"+str(beta)+"_gamma_"+str(gamma)+"_delta_"+str(delta)+"_t_"+str(sim_time)+".csv"


fn = "cartesian_KP_{0}_KD_{1}_alpha_{2}_beta_{3}_gamma_{4}_delta_{5}_t_{6}.csv".format(
                                                                            KP[0], 
                                                                            KD[0], 
                                                                            alpha, 
                                                                            beta, 
                                                                            gamma, 
                                                                            delta, 
                                                                            sim_time)



# save file .csv
path = os.path.join(data_dir, fn)
df.to_csv(path, index=False)

path_tmp = os.path.join(pwd, 'tmp.csv')
df_tmp.to_csv(path_tmp, index=False)

buffer_size = 20
buf = 0
while not rospy.is_shutdown():
    # desired values (cartesian space)
    if not dataset_used:
        p_des, dp_des, ddp_des, dddp_des = circular_trayectory_generator(t)
        p_des, dp_des, ddp_des, dddp_des = np.array(p_des), np.array(dp_des), np.array(ddp_des), np.array(dddp_des)
        rpy_des = rot2rpy(R_des)
        
    else:
        x_des, dx_des, ddx_des, dddx_des = dr.dataset_trajectory_generator()
        p_des = x_des[0:3]
        rpy_des = x_des[3:6]
        dp_des = dx_des[0:3]
        ddp_des = ddx_des[0:3]

    # reference position at Cartesian space
    p_ref, dp_ref, ddp_ref = reference_trajectory(p_des, p_ref, dp_ref, dt)
    
    # reference orientation with Euler angles (ZYX)
    rpy_ref, drpy_ref, ddrpy_ref = reference_trajectory(rpy_des, rpy_ref, drpy_ref, dt)


    if dataset_used:
        # Trajectory Smoothing using Kalman Filter 
        buf += 1
        if buf > buffer_size:
            p_ref, dp_ref, _ = kf_p_ref.update(p_ref, dp_ref)
            rpy_ref, drpy_ref, _ = kf_rpy_ref.update(rpy_ref, drpy_ref)
        else:
            _, _, _ = kf_p_ref.update(p_ref, dp_ref)
            _, _, _ = kf_rpy_ref.update(rpy_ref, drpy_ref)


    R_ref = rpy2rot(rpy_ref)
    w_ref = angular_velocity_rpy(rpy_ref, drpy_ref)
    dw_ref = angular_acceleration_rpy(rpy_ref, drpy_ref, ddrpy_ref)
    # desired pose acceleration
    ddpw_ref = np.concatenate((ddp_ref,dw_ref), axis=0)

    # Cartesian error: position
    p_e[0:3]   =  p_ref - p_med # [3x3]
    dp_e[0:3]  =  dp_ref - dp_med
    ddp_e[0:3] =  ddp_ref - ddp_med

    # Carteisan error: orientation
    p_e[3:6] 	= axisangle_error(R_ref, R_med)
    dp_e[3:6] 	= w_ref - w_med
    ddp_e[3:6]  = dw_ref - dw_med

    # Kalman update
    dp_e_kf, ddp_e_kf, dddp_e_kf = kf.update(dp_e, ddp_e)

    # jacobian: pose [6x6]
    J = nomi_robot.geometric_jacobian(q_med)  
    # jacobian: damped pseudo-inverse [6x6]
    J_inv = damped_pinv(J)   
    # jacobian: time-derivative [6x6]
    dJ = nomi_robot.geometric_jacobian_time_derivative(q_med, dq_med)

    # computes robot dynamics (Cartesian space)
    M  = pin.crba(nomi_robot.robot.model, real_robot.robot.data, real_robot.q)#nomi_robot.get_M() 
    M_p = damped_pinv(J.dot(np.linalg.inv(M).dot(J.T))) # inertia matrix at Cartesian space

    b = pin.rnea(nomi_robot.robot.model, real_robot.robot.data, real_robot.q, real_robot.dq, np.zeros(ndof))#nomi_robot.get_b() 
    b_p = J_inv.T.dot(b) - M_p.dot(dJ.dot(dq_med)) # nonlinear effects vector at Joint space at Cartesian space

    # cartesian PD control + Feedback linearization
    F = M_p.dot(ddpw_ref + np.multiply(KP, p_e) + np.multiply(KD, dp_e)) + b_p
    u = J.T.dot(F) 

    # Send control signal
    real_robot.send_control_command(u)

    # update states
    q_med, dq_med, ddq_med = real_robot.read_joint_position_velocity_acceleration()
    p_med, dp_med, ddp_med = real_robot.read_cartesian_position_velocity_acceleration()

    R_med = real_robot.read_ee_orientation()
    w_med, dw_med = real_robot.read_ee_angular_velocity_acceleration()

    # represent orientation with Euler angles
    angle_med, axis_med = rot2axisangle(R_med)
    axis_angle_med = angle_med*axis_med

    angle_ref, axis_ref = rot2axisangle(R_ref)
    axis_angle_ref = angle_ref*axis_ref

    axis_angle_e = axisangle_error(R_ref, R_med)  

    # Publish message
    jstate.header.stamp = rospy.Time.now()
    jstate.name 		= jnames			# Joints position name
    jstate.position 	= q_med
    jstate.velocity 	= dq_med
    pub.publish(jstate)

    # Ball marker
    bmarker_des.xyz(p_ref[0:3])	# Green
    bmarker_act.xyz(p_med[0:3])	# Yellow          
    amarker_ref.xyz(p_ref[0:3])
    amarker_ref.rotation(R_ref)

    bmarker_act.publish()
    bmarker_des.publish()
    amarker_ref.publish()
    # ================
    # 	optimization 
    # ================
    # Derivative of Kp and Kd
    dKP = -(alpha/dt) * (dJ_KP)
    dKD = -(alpha/dt) * (dJ_KD)

    # special parameters
    P1 = np.multiply(KP,p_e) + np.multiply(KD, dp_e)
    P2 = -np.multiply(dKP, p_e)   - np.multiply(KP, dp_e) \
         -np.multiply(dKD, dp_e) - np.multiply(KD, ddp_e)

    #cost function
    c = gamma*0.5*np.dot(P1.T,P1) + beta*0.5*np.dot(P2.T,P2) 	# [1x1]

    # Gradient descent
    dP1_q = -copy(KP)					# [6x1]
    dP2_q = copy(dKP) 					# [6x1]	

    # partial derivative of J (cost) with respecto to q(output)
    dJ_q  = gamma*np.multiply(P1, dP1_q) + beta*np.multiply(P2, dP2_q)	# [6x1]

    # partial derivative of q (output) with respect to u (control)
    dpw_med = np.concatenate((dp_med, w_med), axis=0)
    dF = (F-Fp)#*nonzero
    dq_du = np.sign(np.multiply(dpw_med, dF))

    # partial derivative of u (control) with respect to k (control gain)
    du_KP = np.dot(M_p, p_e)				# [6x1]
    du_KD = np.dot(M_p, dp_e)   			# [6x1]

    # gradient with respecto to each control gain
    dJ_KP = np.multiply(dJ_q, du_KP) 	# [6x1]
    dJ_KD = np.multiply(dJ_q, du_KD) 	# [6x1]	    

    # convergence conditions
    convergence_position = 0.001*max_pos_error*np.ones(3)           # [m]
    convergence_orientation = np.deg2rad(max_ori_error)*np.ones(3)  # [rad]
    convergence_pose = np.concatenate((convergence_position, convergence_orientation), axis=0) # [m, rad]
    crit_p = 1*(abs(p_e)>=convergence_pose)

    convergence_jerk = 0.001 * max_jerk * np.ones(6)
    crit_j = 1*(abs(dddp_e_kf)>=convergence_jerk)

    # Clip
    dJ_KP = np.clip(dJ_KP, -0.02, 0.02)
    dJ_KD = np.clip(dJ_KD, -0.02, 0.02)

    # Upgrade control gains
    KP = KP - alpha*crit_p*crit_j*dJ_KP 	#[6x1]  
    KD = KD - alpha*crit_p*crit_j*dJ_KD 	#[6x1]	    



    # Print
    if (np.round(t/dt,1)%10==0):
        print("t: ", np.round(t,2))
        print("crit_p: ", crit_p)
        print("p_e", 1000*p_e[0:3])
        print("o_e", np.rad2deg(p_e[3:6]))
        print("KP: ", KP)
        print("KD: ", KD) 
        print("\n")    

    # Append data
    row = 	tl(np.array([t])) +\
            tl(p_med)+tl(dp_med)+tl(ddp_med)+tl(dddp_med) +\
            tl(p_ref)+tl(dp_ref)+tl(ddp_ref)+tl(dddp_ref) +\
            tl(axis_angle_med)+tl(axis_angle_ref)+tl(axis_angle_e) +\
            tl(q_med)+tl(dq_med)+tl(ddq_med) +\
            tl(q_ref)+tl(dq_ref)+tl(ddq_ref) +\
            tl(KP) +\
            tl(KD) +\
            tl(u)  +\
            tl(np.array([c]))
    # Fix for redimensionality
    row = tl(np.expand_dims(np.array(row), axis = 1))

    row_tmp = tl(dp_e) +\
                tl(ddp_e) +\
                tl(dp_e_kf) +\
                tl(ddp_e_kf) +\
                tl(dddp_e_kf) +\
                tl(p_ref)+tl(dp_ref)+tl(ddp_ref)+tl(dddp_ref)  +\
                tl(p_des)+tl(dp_des)+tl(ddp_des)

    row_tmp = tl(np.expand_dims(np.array(row_tmp), axis = 1))

    df_row = pd.DataFrame.from_dict(dict(zip(column_names, row)))
    df.append(df_row, sort = False).to_csv(path, index=False, mode = 'a', header=False)

    df_row_tmp = pd.DataFrame.from_dict(dict(zip(column_tmp, row_tmp)))
    df_tmp.append(df_row_tmp, sort = False).to_csv(path_tmp, index=False, mode = 'a', header=False)


    # Update
    t = t + dt
    Fp = copy(F)

    if dataset_used:
        if dr.check():
            print("Reached maximum of steps")
            break


    if t>=(sim_time): # 60 sec
        print("Reached maximum of steps")
        print("data created with name: ", fn)
        break

    # Wait for the next iteration
    rate.sleep()

print('out because ctrl + c. Data saved.')            

